name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    paths-ignore: 
      - '**.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY_NAME }}
  IMAGE_TAG: ${{ github.sha }}
  CONTAINER_NAME: networksecurity
  APP_PORT: 8000

jobs:
  # ==============================================================================
  # CONTINUOUS INTEGRATION
  # ==============================================================================
  ci:
    name: üîç Code Quality & Testing
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for proper diff analysis

      - name: üîç Detect Changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            should-deploy:
              - 'src/**'
              - 'requirements.txt'
              - 'Dockerfile'
              - 'app.py'
              - '.github/workflows/**'

      - name: üêç Setup Python
        if: steps.changes.outputs.should-deploy == 'true'
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          
      - name: üì¶ Install Dependencies
        if: steps.changes.outputs.should-deploy == 'true'
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          # Install dev dependencies for linting/testing
          pip install flake8 pytest black isort safety bandit

      - name: üßπ Code Formatting Check
        if: steps.changes.outputs.should-deploy == 'true'
        run: |
          black --check --diff .
          isort --check-only --diff .

      - name: üîç Lint Code
        if: steps.changes.outputs.should-deploy == 'true'
        run: |
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: üîí Security Scan
        if: steps.changes.outputs.should-deploy == 'true'
        run: |
          safety check
          bandit -r . -f json -o bandit-report.json || true

      - name: üß™ Run Tests
        if: steps.changes.outputs.should-deploy == 'true'
        run: |
          if [ -d "tests" ]; then
            python -m pytest tests/ -v --tb=short
          else
            echo "No tests directory found, skipping tests"
          fi

      - name: üìä Upload Test Results
        if: always() && steps.changes.outputs.should-deploy == 'true'
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            bandit-report.json
            .coverage
          retention-days: 7

  # ==============================================================================
  # BUILD AND PUSH TO ECR
  # ==============================================================================
  build:
    name: üèóÔ∏è Build & Push Container
    runs-on: ubuntu-latest
    needs: ci
    if: needs.ci.outputs.should-deploy == 'true' && github.ref == 'refs/heads/main'
    timeout-minutes: 30
    
    outputs:
      image-uri: ${{ steps.build.outputs.image }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:v0.12.0

      - name: üè∑Ô∏è Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.AWS_ECR_LOGIN_URI }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: ‚òÅÔ∏è Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          mask-aws-account-id: false

      - name: üîë Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: üèóÔ∏è Ensure ECR Repository Exists
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} 2>/dev/null || \
          aws ecr create-repository \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

      - name: üîç Validate Application Files
        run: |
          required_files=("requirements.txt" "app.py" "Dockerfile")
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Required file missing: $file"
              exit 1
            fi
            echo "‚úÖ Found: $file"
          done
          
          # Create missing directories if needed
          if [[ ! -d "networksecurity" ]]; then
            echo "‚ö†Ô∏è Creating networksecurity directory structure..."
            mkdir -p networksecurity/templates
            echo '<html><body><h1>Network Security App</h1>{{table}}</body></html>' > networksecurity/templates/table.html
          fi

      - name: üê≥ Build and Push Docker Image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}
            REVISION=${{ github.sha }}

      - name: üîç Scan Image for Vulnerabilities
        run: |
          # Install Trivy
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy
          
          # Scan the built image
          trivy image --exit-code 1 --severity HIGH,CRITICAL ${{ steps.build.outputs.tags }} || echo "‚ö†Ô∏è Vulnerabilities found but continuing..."

  # ==============================================================================
  # CONTINUOUS DEPLOYMENT
  # ==============================================================================
  deploy:
    name: üöÄ Deploy Application
    runs-on: self-hosted
    needs: [ci, build]
    if: success() && github.ref == 'refs/heads/main'
    timeout-minutes: 20
    
    environment:
      name: production
      url: http://localhost:8000
      
    steps:
      - name: üßπ Pre-deployment Cleanup
        run: |
          # Clean Git config
          git config --global --unset-all safe.directory 2>/dev/null || true
          git config --local --unset-all core.sshCommand 2>/dev/null || true
          git config --local --unset-all http.https://github.com/.extraheader 2>/dev/null || true
          
          # Clean Docker resources
          docker system prune -f --volumes
          
          echo "‚úÖ Pre-deployment cleanup completed"
        continue-on-error: true

      - name: üíª Verify System Requirements
        run: |
          echo "üîç System Check:"
          echo "OS: $(uname -a)"
          echo "Docker: $(docker --version)"
          echo "AWS CLI: $(aws --version)"
          echo "Available Memory: $(free -h | grep '^Mem' | awk '{print $7}')"
          echo "Available Disk: $(df -h . | tail -1 | awk '{print $4}')"
          
          # Check if we have enough resources
          available_memory=$(free -m | grep '^Mem' | awk '{print $7}')
          if (( available_memory < 512 )); then
            echo "‚ö†Ô∏è Low memory warning: ${available_memory}MB available"
          fi

      - name: ‚òÅÔ∏è Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîë Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: üì• Pull Latest Image
        run: |
          image_uri="${{ needs.build.outputs.image-uri }}"
          echo "üì• Pulling image: $image_uri"
          
          if ! docker pull "$image_uri"; then
            echo "‚ùå Failed to pull image"
            echo "Available images in ECR:"
            aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} --max-items 5
            exit 1
          fi
          
          echo "‚úÖ Image pulled successfully"
          docker tag "$image_uri" "${{ env.CONTAINER_NAME }}:latest"

      - name: üõë Graceful Container Shutdown
        run: |
          if container_id=$(docker ps -q -f name=${{ env.CONTAINER_NAME }}); then
            echo "üõë Gracefully stopping existing container..."
            docker stop --time=30 "$container_id"
            docker rm "$container_id"
            echo "‚úÖ Container stopped and removed"
          else
            echo "‚ÑπÔ∏è No running container found"
          fi
          
          # Clean up any stopped containers
          docker container prune -f
        continue-on-error: true

      - name: üîå Check Port Availability
        run: |
          if lsof -Pi :${{ env.APP_PORT }} -sTCP:LISTEN -t >/dev/null; then
            echo "‚ö†Ô∏è Port ${{ env.APP_PORT }} is in use, attempting cleanup..."
            sudo lsof -ti:${{ env.APP_PORT }} | xargs -r sudo kill -9
            sleep 5
            
            if lsof -Pi :${{ env.APP_PORT }} -sTCP:LISTEN -t >/dev/null; then
              echo "‚ùå Unable to free port ${{ env.APP_PORT }}"
              exit 1
            fi
          fi
          echo "‚úÖ Port ${{ env.APP_PORT }} is available"

      - name: üöÄ Deploy New Container
        run: |
          echo "üöÄ Starting new container..."
          
          container_id=$(docker run -d \
            --name=${{ env.CONTAINER_NAME }} \
            --restart=unless-stopped \
            --memory=1g \
            --cpus=1.0 \
            --health-cmd="curl -f http://localhost:${{ env.APP_PORT }}/health || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            --health-start-period=40s \
            -p ${{ env.APP_PORT }}:${{ env.APP_PORT }} \
            -e AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -e AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -e AWS_REGION="${{ env.AWS_REGION }}" \
            -e MONGODB_URL_KEY="${{ secrets.MONGODB_URL_KEY }}" \
            -e ENVIRONMENT=production \
            -e PORT=${{ env.APP_PORT }} \
            "${{ env.CONTAINER_NAME }}:latest")
          
          echo "‚úÖ Container started: $container_id"
          echo "CONTAINER_ID=$container_id" >> $GITHUB_ENV

      - name: ‚è≥ Health Check
        run: |
          echo "‚è≥ Waiting for application to be ready..."
          max_attempts=20
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts..."
            
            # Check if container is still running
            if ! docker ps -q -f id=${{ env.CONTAINER_ID }} | grep -q .; then
              echo "‚ùå Container stopped unexpectedly"
              docker logs ${{ env.CONTAINER_ID }} --tail 50
              exit 1
            fi
            
            # Check health endpoint
            if curl -f -s http://localhost:${{ env.APP_PORT }}/docs >/dev/null 2>&1; then
              echo "‚úÖ Application is healthy and responding"
              break
            fi
            
            if [ $attempt -eq $max_attempts ]; then
              echo "‚ùå Health check failed after $max_attempts attempts"
              echo "Container logs:"
              docker logs ${{ env.CONTAINER_ID }} --tail 50
              exit 1
            fi
            
            sleep 15
            ((attempt++))
          done

      - name: üìä Deployment Summary
        if: always()
        run: |
          echo "üìä Deployment Summary:"
          echo "Image: ${{ needs.build.outputs.image-uri }}"
          echo "Digest: ${{ needs.build.outputs.image-digest }}"
          echo "Container: ${{ env.CONTAINER_ID }}"
          echo "Port: ${{ env.APP_PORT }}"
          echo "Health: $(curl -s -o /dev/null -w '%{http_code}' http://localhost:${{ env.APP_PORT }}/docs || echo 'FAILED')"
          
          if docker ps -f name=${{ env.CONTAINER_NAME }} --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | grep -q ${{ env.CONTAINER_NAME }}; then
            echo "Status: ‚úÖ RUNNING"
          else
            echo "Status: ‚ùå FAILED"
          fi

      - name: üßπ Post-deployment Cleanup
        if: always()
        run: |
          # Remove old images (keep last 3)
          docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.CreatedAt}}" | \
          grep ${{ env.CONTAINER_NAME }} | tail -n +4 | awk '{print $3}' | \
          xargs -r docker rmi -f 2>/dev/null || true
          
          # Clean Git config
          git config --global --unset-all safe.directory 2>/dev/null || true
          git config --local --unset-all core.sshCommand 2>/dev/null || true
          git config --local --unset-all http.https://github.com/.extraheader 2>/dev/null || true
          
          echo "‚úÖ Cleanup completed"
        continue-on-error: true

  # ==============================================================================
  # NOTIFICATION
  # ==============================================================================
  notify:
    name: üì¢ Notify Results
    runs-on: ubuntu-latest
    needs: [ci, build, deploy]
    if: always()
    
    steps:
      - name: üì¢ Deployment Notification
        if: always()
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "‚úÖ Deployment completed successfully"
            echo "üîó Application URL: http://localhost:${{ env.APP_PORT }}"
          else
            echo "‚ùå Deployment failed"
            echo "CI Status: ${{ needs.ci.result }}"
            echo "Build Status: ${{ needs.build.result }}"
            echo "Deploy Status: ${{ needs.deploy.result }}"
          fi